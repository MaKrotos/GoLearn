# День 7: Подготовка к вопросам (8 часов)

## Технические вопросы (заучить ответы)

### Про горутины

#### "Горутины легковеснее потоков, планируются рантаймом Go"

Горутины - это функции или методы, которые выполняются независимо в рамках одного адресного пространства. Они управляются планировщиком Go, который мультиплексирует горутины на меньшее количество потоков ОС.

**Преимущества горутин:**
- Низкие накладные расходы на создание (около 2KB стека)
- Быстрое переключение контекста
- Эффективное использование ресурсов

#### "GOMAXPROCS определяет количество потоков ОС для выполнения горутин"

GOMAXPROCS определяет максимальное количество процессоров, которые могут одновременно выполнять код Go. По умолчанию равно количеству ядер CPU.

```go
// Получение текущего значения
fmt.Println(runtime.GOMAXPROCS(0))

// Установка значения
runtime.GOMAXPROCS(4)
```

### Про память

#### "GC использует три-color маркировку, паузы < 1ms в современных версиях"

Сборщик мусора Go использует алгоритм три-color маркировки:
1. **Белый** - объекты, которые еще не обработаны
2. **Серый** - объекты, которые обнаружены, но не полностью обработаны
3. **Черный** - объекты, которые полностью обработаны

Современные версии Go (с 1.8) используют конкурентный GC с паузами менее 1мс.

#### "Escape analysis определяет, попадет ли переменная в кучу"

Escape analysis - это процесс, с помощью которого компилятор определяет, где должна быть размещена переменная: в стеке или в куче.

```go
// Переменная размещается в стеке
func stackAllocation() int {
    x := 42
    return x // x не "escape" из функции
}

// Переменная размещается в куче
func heapAllocation() *int {
    x := 42
    return &x // x "escape" в кучу, так как возвращается указатель
}
```

### Про ошибки

#### "Использую errors.Is() и errors.As() для проверки ошибок, errors.Join() для агрегации"

Современный подход к работе с ошибками в Go:

```go
import (
    "errors"
    "fmt"
)

// Проверка ошибок с errors.Is()
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("Файл не существует")
}

// Проверка ошибок с errors.As()
var pathError *os.PathError
if errors.As(err, &pathError) {
    fmt.Printf("Ошибка пути: %v\n", pathError)
}

// Агрегация ошибок с errors.Join()
func processFiles(files []string) error {
    var errs []error
    for _, file := range files {
        if err := processFile(file); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return errors.Join(errs...)
    }
    return nil
}
```

### Про тестирование

#### "Пишу табличные тесты, использую httptest для мока HTTP вызовов"

Табличные тесты позволяют проверить множество сценариев в одном тесте:

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, 1, 0},
        {"zero", 0, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

Использование httptest для тестирования HTTP обработчиков:

```go
func TestUserHandler(t *testing.T) {
    req := httptest.NewRequest("GET", "/users/1", nil)
    w := httptest.NewRecorder()
    
    userHandler(w, req)
    
    resp := w.Result()
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Expected status OK; got %v", resp.Status)
    }
}
```

## Поведенческие вопросы

### "Расскажите о сложном проекте" → Говорите про оптимизацию, масштабирование, решение проблем

При ответе на этот вопрос следуйте структуре STAR:
- **S**ituation - Опишите ситуацию
- **T**ask - Какая была задача
- **A**ction - Какие действия вы предприняли
- **R**esult - Какой был результат

Пример ответа:
"В одном из проектов мы столкнулись с проблемой медленной обработки заказов. После анализа с помощью pprof я обнаружил, что узким местом была база данных. Я реализовал кэширование с помощью Redis и оптимизировал запросы, что уменьшило время обработки заказа с 500мс до 50мс."

### "Почему уходите?" → "Хочу сложных задач, развития, работал над..."

Честно, но позитивно отвечайте на этот вопрос:
- "Ищу новые вызовы и возможности для профессионального роста"
- "Хочу работать над более масштабными проектами"
- "Интересуют технологии, которые активно развиваются в вашей компании"

## Чек-лист готовности

### ☐ Могу объяснить разницу goroutine vs thread

**Горутина:**
- Управляется рантаймом Go
- Стартует с ~2KB стека
- Быстрое переключение контекста
- Множество горутин на один поток ОС

**Поток ОС:**
- Управляется операционной системой
- Больше накладных расходов
- Медленное переключение контекста
- Ограниченное количество потоков

### ☐ Знаю когда использовать mutex vs channel

**Mutex:**
- Защита общего состояния
- Когда нужно изменять данные
- Простая синхронизация

**Channel:**
- Коммуникация между горутинами
- Передача данных
- Когда нужно координировать выполнение

### ☐ Могу написать HTTP сервер с middleware

```go
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Printf("%s %s", r.Method, r.URL.Path)
        next.ServeHTTP(w, r)
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/api", handler)
    
    http.ListenAndServe(":8080", loggingMiddleware(mux))
}
```

### ☐ Понимаю context и его применение

Context используется для:
- Отмены операций
- Передачи метаданных
- Управления таймаутами

### ☐ Знаю как тестировать и профилировать код

**Тестирование:**
- Табличные тесты
- httptest для HTTP обработчиков
- Моки для внешних зависимостей

**Профилирование:**
- pprof для CPU/memory анализа
- go test -bench для бенчмарков
- go test -race для детектора гонок

### ☐ Могу объяснить чистую архитектуру

Три слоя:
1. **Delivery** - обработка входящих запросов
2. **Business logic** - бизнес-логика приложения
3. **Repository** - работа с данными

### ☐ Знаю основные пакеты стандартной библиотеки

- net/http - HTTP серверы и клиенты
- encoding/json - работа с JSON
- database/sql - работа с базами данных
- testing - тестирование
- context - контекст выполнения

### ☐ Могу решить задачу на алгоритмы средней сложности

Практикуйтесь в решении задач на:
- Строки и массивы
- Связные списки
- Деревья и графы
- Динамическое программирование

### ☐ Готов к вопросам про системное проектирование

Уметь проектировать:
- Распределенные системы
- Системы с высокой нагрузкой
- Масштабируемые архитектуры

## Ключевая стратегия

**Не пытайтесь выучить все. Сфокусируйтесь на демонстрации понимания основных концепций и уверенности в ответах. На собеседовании важнее показать ход мыслей, чем дать идеальный ответ.**

## Практические задания

1. Проведите пробное собеседование с другом или перед зеркалом
2. Решите 5 алгоритмических задач
3. Напишите эссе на тему "Почему я хочу работать в вашей компании"
4. Подготовьте рассказ о своем самом сложном проекте
5. Повторите ключевые концепции Go