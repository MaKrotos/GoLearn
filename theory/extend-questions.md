Уточняющие вопросы к существующим темам
Goroutines & Concurrency
К вопросу 1 (goroutine):

Что такое GOMAXPROCS и как это влияет на выполнение goroutine?

Как работает рост стека goroutine? Что происходит при stack overflow?

Что такое "work-stealing" в планировщике и как это повышает эффективность?

К вопросу 3 (каналы):

Что происходит при отправке в закрытый канал? А при чтении из закрытого канала?

Как реализован канал "под капотом"? (hchan структура)

Когда использовать каналы, а когда mutex? Какие критерии выбора?

К вопросу 4 (select):

Что будет, если в select несколько case готовы одновременно?

Как реализован non-blocking select с default?

Что такое "starvation" в select и как её избежать?

Memory Management & GC
К вопросу 5 (garbage collector):

Что такое три-цветная маркировка (tricolor marking) и как она работает?

Как GC влияет на latency приложения? Что такое STW паузы?

Как работает escape analysis и как она влияет на производительность?

К вопросу 23 (оптимизация памяти):

Как устроен sync.Pool внутри? Когда объекты из пула удаляются?

Что такое memory ballast и как это помогает производительности GC?

Как читать и интерпретировать memory профили?

Интерфейсы и типы
К вопросу 7 (интерфейсы):

Как устроен интерфейс "под капотом"? (iface, eface)

В чем разница между var i interface{} и конкретным типом?

Что такое "interface pollution" и как её избежать?

К вопросу 8 (пустой интерфейс):

Когда использование interface{} оправдано, а когда стоит избегать?

Как type switch отличается от type assertion?

Что такое "comma-ok idiom" в контексте type assertion?

Контекст и управление жизненным циклом
К вопросу 6 (context):

Как правильно передавать context в цепочке вызовов?

Что происходит при отмене контекста? Как это распространяется?

Когда не стоит использовать context.WithValue?

Синхронизация
К вопросу 16 (Mutex vs RWMutex):

Когда RWMutex может быть медленнее обычного Mutex?

Что такое "writer starvation" в RWMutex и как это исправить?

Как работает Mutex внутри? (режимы starvation mode, normal mode)

К вопросу 17 (atomic операции):

Что такое memory ordering и как atomic операции с этим связаны?

В чем разница между atomic.Load и обычным чтением?

Когда atomic недостаточно и нужен mutex?

Тестирование
К вопросу 37 (тестирование с зависимостями):

Как тестировать код, который зависит от времени (time.Now, timers)?

Как mock'ать внешние HTTP API?

Что такое "test fixtures" и как их правильно организовать?

К вопросу 38 (тестирование конкурентного кода):

Как написать детерминированный тест для конкурентного кода?

Что такое "fuzzy testing" для конкурентности?

Как использовать -race flag в CI/CD pipeline?

Профилирование и отладка
К вопросу 21 (pprof):

Как интерпретировать flame graph?

В чем разница между alloc_space и inuse_space?

Как профилировать блокировки и планировщик?

К вопросу 24 (отладка):

Как отлаживать deadlock в production?

Как использовать tracing в Go?

Что такое "core dump" и как его анализировать?

Системный дизайн
К вопросу 27 (rate limiting):

В чем разница между Token Bucket и Leaky Bucket?

Как реализовать distributed rate limiting?

Как rate limiting влияет на fairness между пользователями?

К вопросу 29 (отказоустойчивость):

Как реализовать retry с exponential backoff?

Что такое "circuit breaker pattern" и как выбрать параметры?

Как организовать graceful shutdown в микросервисной архитектуре?

Базы данных
К вопросу 31 (database/sql):

Как работает connection pooling в database/sql?

Что такое "prepared statements" и как они кэшируются?

Как правильно обрабатывать транзакции с retry логикой?

К вопросу 32 (ORM проблемы):

Как избежать N+1 проблемы без преждевременной оптимизации?

Когда стоит использовать raw SQL вместо ORM?

Как ORM влияет на миграции схемы базы данных?

Практические нюансы
К вопросу 9 (defer):

Как defer влияет на производительность? Когда это значимо?

Что такое "defer panic" и как это обрабатывать?

Как изменить возвращаемое значение функции в defer?

К вопросу 10 (panic/recover):

Какие best practices использования panic/recover?

Как обрабатывать panics в goroutine?

Когда использовать panic для бизнес-логики?

Архитектурные паттерны
К вопросу 13 (архитектура приложения):

Как организовать валидацию в разных слоях приложения?

Как обрабатывать ошибки между слоями?

Как реализовать CQRS на Go?

К вопросу 14 (worker pool):

Как реализовать dynamic worker pool?

Как обрабатывать graceful shutdown worker pool?

Как балансировать нагрузку между worker'ами?

Производственные вопросы
К вопросу 25 (production сборка):

Как использовать build tags для feature flags?

Как уменьшить размер бинарника?

Как настраивать разные конфигурации для разных окружений?

Общие уточняющие:

"Расскажите о самом сложном баге, который вы исправляли в Go"

"Как вы мониторите производительность Go приложений в production?"

"Какие ограничения Go вы встречали в реальных проектах и как обходили?"

"Как вы принимаете решение между sync и async обработкой?"
