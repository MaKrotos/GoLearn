# Уточняющие вопросы по Go

## Goroutines & Concurrency

### К вопросу 1 (goroutine)

**Что такое GOMAXPROCS и как это влияет на выполнение goroutine?**
- Как GOMAXPROCS связан с количеством CPU ядер?
- Что происходит при GOMAXPROCS=1?
- Как динамически изменить GOMAXPROCS во время выполнения?

**Как работает рост стека goroutine? Что происходит при stack overflow?**
- Какой начальный размер стека у goroutine?
- Как происходит копирование стека при росте?
- Можно ли контролировать максимальный размер стека?

**Что такое "work-stealing" в планировщике и как это повышает эффективность?**
- Как планировщик балансирует нагрузку между потоками?
- В каких сценариях work-stealing наиболее эффективен?

### К вопросу 3 (каналы)

**Что происходит при отправке в закрытый канал? А при чтении из закрытого канала?**
- Какая паника возникает при отправке в закрытый канал?
- Почему чтение из закрытого канала возвращает нулевое значение?
- Как отличить закрытый канал от открытого при чтении?

**Как реализован канал "под капотом"? (hchan структура)**
- Из каких основных компонентов состоит hchan?
- Как работает блокировка при отправке/получении?
- Как буферизованные каналы отличаются от небуферизованных?

**Когда использовать каналы, а когда mutex? Какие критерии выбора?**
- В каких сценариях каналы эффективнее мьютексов?
- Когда мьютексы предпочтительнее для синхронизации?
- Как выбирать между CSP и shared memory подходами?

### К вопросу 4 (select)

**Что будет, если в select несколько case готовы одновременно?**
- Как Go выбирает какой case выполнить?
- Гарантируется ли случайный выбор?
- Как избежать голодания определенного case?

**Как реализован non-blocking select с default?**
- Что происходит при вызове select с default?
- Как это используется для проверки готовности каналов?

**Что такое "starvation" в select и как её избежать?**
- Может ли один case постоянно блокировать другие?
- Как организовать fair selection между каналами?

## Memory Management & GC

### К вопросу 5 (garbage collector)

**Что такое три-цветная маркировка (tricolor marking) и как она работает?**
- Какие три цвета используются и что они означают?
- Как обеспечивается корректность при параллельной маркировке?
- Что такое write barrier и зачем он нужен?

**Как GC влияет на latency приложения? Что такое STW паузы?**
- Какие фазы GC требуют остановки мира?
- Как GOGC параметр влияет на частность сборок?
- Какие техники уменьшения GC pause времени существуют?

**Как работает escape analysis и как она влияет на производительность?**
- Как определить куда аллоцируется переменная?
- Какие паттерны заставляют переменные escape в кучу?
- Как использовать escape analysis для оптимизации?

### К вопросу 23 (оптимизация памяти)

**Как устроен sync.Pool внутри? Когда объекты из пула удаляются?**
- Как работает кэширование объектов в пуле?
- Когда GC очищает объекты из sync.Pool?
- Какие best practices использования sync.Pool?

**Что такое memory ballast и как это помогает производительности GC?**
- Как memory ballast влияет на GOGC?
- Как правильно настроить размер ballast?
- Какие подводные камни у этого подхода?

**Как читать и интерпретировать memory профили?**
- Какие типы аллокаций показываются в профиле?
- Как найти memory leaks через pprof?
- Как анализировать heap fragmentation?

## Интерфейсы и типы

### К вопросу 7 (интерфейсы)

**Как устроен интерфейс "под капотом"? (iface, eface)**
- В чем разница между iface и eface?
- Как хранятся тип и значение в интерфейсе?
- Что такое itab и как он кэшируется?

**В чем разница между var i interface{} и конкретным типом?**
- Какие overhead при использовании интерфейсов?
- Когда boxing/unboxing происходит неявно?
- Как избежать лишних аллокаций с интерфейсами?

**Что такое "interface pollution" и как её избежать?**
- Когда интерфейсы избыточны в дизайне?
- Как применять Interface Segregation Principle в Go?
- Какие критерии для создания интерфейсов?

### К вопросу 8 (пустой интерфейс)

**Когда использование interface{} оправдано, а когда стоит избегать?**
- В каких сценариях empty interface необходим?
- Какие альтернативы generic до Go 1.18?
- Как типизация помогает избежать runtime ошибок?

**Как type switch отличается от type assertion?**
- Когда использовать type assertion vs type switch?
- Какая паника при неудачном type assertion?
- Как безопасно выполнять type assertion?

**Что такое "comma-ok idiom" в контексте type assertion?**
- Как проверить успешность type assertion?
- Какие еще операции используют comma-ok в Go?

## Контекст и управление жизненным циклом

### К вопросу 6 (context)

**Как правильно передавать context в цепочке вызовов?**
- Должен ли context быть первым параметром?
- Как обрабатывать отмену контекста в глубоких цепочках?
- Когда создавать новые контексты (WithCancel, WithTimeout)?

**Что происходит при отмене контекста? Как это распространяется?**
- Как устроено дерево контекстов?
- Какие goroutines получают сигнал отмены?
- Как ресурсы освобождаются при отмене?

**Когда не стоит использовать context.WithValue?**
- Какие данные не стоит хранить в context?
- Какие проблемы с типизацией в WithValue?
- Какие альтернативы передачи метаданных?

## Синхронизация

### К вопросу 16 (Mutex vs RWMutex)

**Когда RWMutex может быть медленнее обычного Mutex?**
- При каком соотношении чтение/запись RWMutex эффективен?
- Какие overhead у RWMutex по сравнению с Mutex?
- Как измерять contention на мьютексах?

**Что такое "writer starvation" в RWMutex и как это исправить?**
- Как RWMutex балансирует приоритеты читателей и писателей?
- Какие настройки есть для предотвращения starvation?
- Когда использовать sync.Map вместо RWMutex?

**Как работает Mutex внутри? (режимы starvation mode, normal mode)**
- Что такое spinlock в реализации Mutex?
- Как работает очередь ожидания в Mutex?
- Когда Mutex переключается между режимами?

### К вопросу 17 (atomic операции)

**Что такое memory ordering и как atomic операции с этим связаны?**
- Какие гарантии памяти предоставляет Go memory model?
- В чем разница между sequential consistency и relaxed ordering?
- Как atomic.Load/Store влияют на видимость изменений?

**В чем разница между atomic.Load и обычным чтением?**
- Когда нужно использовать atomic для чтения?
- Какие типы поддерживают atomic операции?
- Как atomic сравнивается с volatile в других языках?

**Когда atomic недостаточно и нужен mutex?**
- Какие операции нельзя выразить через atomic?
- Как комбинировать atomic с другими примитивами?
- Что такое "sync/atomic" vs "sync" packages?

## Тестирование

### К вопросу 37 (тестирование с зависимостями)

**Как тестировать код, который зависит от времени (time.Now, timers)?**
- Как использовать интерфейсы для абстракции времени?
- Что такое "test clocks" и как их реализовать?
- Как тестировать код с time.Sleep и таймерами?

**Как mock'ать внешние HTTP API?**
- Как использовать httptest.Server для моков?
- Какие библиотеки для мокинга HTTP клиентов?
- Как тестировать retry логику и circuit breakers?

**Что такое "test fixtures" и как их правильно организовать?**
- Где хранить тестовые данные (JSON, YAML, Go files)?
- Как управлять состоянием между тестами?
- Какие best practices для test helpers?

### К вопросу 38 (тестирование конкурентного кода)

**Как написать детерминированный тест для конкурентного кода?**
- Как использовать каналы для синхронизации в тестах?
- Что такое "testing/race" для обнаружения гонок?
- Как тестировать timeout и cancellation?

**Что такое "fuzzy testing" для конкурентности?**
- Как использовать go test -race многократно?
- Какие инструменты для stress testing?
- Как автоматически обнаруживать flaky tests?

**Как использовать -race flag в CI/CD pipeline?**
- Какие overhead при использовании race detector?
- Как интерпретировать race detection reports?
- Когда race detector может пропустить гонки?

## Профилирование и отладка

### К вопросу 21 (pprof)

**Как интерпретировать flame graph?**
- Как читать ширину и глубину стека в flame graph?
- Какие типы flame graphs существуют (CPU, memory, goroutine)?
- Как найти bottlenecks через flame graph?

**В чем разница между alloc_space и inuse_space?**
- Когда использовать каждый тип memory профиля?
- Как анализировать cumulative vs current allocations?
- Как найти memory leaks через diff профилей?

**Как профилировать блокировки и планировщик?**
- Какие mutex и block профили доступны?
- Как интерпретировать contention профили?
- Как профилировать goroutine scheduling?

### К вопросу 24 (отладка)

**Как отлаживать deadlock в production?**
- Как использовать goroutine dump для анализа deadlock?
- Какие инструменты для runtime анализа блокировок?
- Как настроить timeout для обнаружения deadlocks?

**Как использовать tracing в Go?**
- В чем разница между tracing и profiling?
- Какие события можно отслеживать через execution tracer?
- Как анализировать trace файлы?

**Что такое "core dump" и как его анализировать?**
- Как настроить core dump в production?
- Какие инструменты для анализа core dump в Go?
- Как найти причину panic через core dump?

## Системный дизайн

### К вопросу 27 (rate limiting)

**В чем разница между Token Bucket и Leaky Bucket?**
- Какие алгоритмы реализованы в golang.org/x/time/rate?
- Как выбрать параметры burst и rate?
- Как тестировать rate limiting логику?

**Как реализовать distributed rate limiting?**
- Какие подходы с Redis или другими хранилищами?
- Как обеспечить consistency между нодами?
- Какие trade-offs у distributed rate limiting?

**Как rate limiting влияет на fairness между пользователями?**
- Как обеспечить fair sharing между клиентами?
- Что такое "sticky limits" и как избежать?
- Как балансировать rate limits между микросервисами?

### К вопросу 29 (отказоустойчивость)

**Как реализовать retry с exponential backoff?**
- Какие библиотеки для retry логики в Go?
- Как настроить jitter для предотвращения thundering herd?
- Какие критерии для прекращения retry?

**Что такое "circuit breaker pattern" и как выбрать параметры?**
- Какие состояния у circuit breaker?
- Как настроить thresholds и timeouts?
- Как мониторить состояние circuit breakers?

**Как организовать graceful shutdown в микросервисной архитектуре?**
- Как обрабатывать SIGTERM и SIGINT?
- Какие timeout для graceful shutdown?
- Как координировать shutdown между зависимостями?

## Базы данных

### К вопросу 31 (database/sql)

**Как работает connection pooling в database/sql?**
- Как настроить max open connections и max idle connections?
- Какие проблемы с long-lived connections?
- Как мониторить pool utilization?

**Что такое "prepared statements" и как они кэшируются?**
- В чем преимущества prepared statements?
- Как работает prepared statement caching на клиенте и сервере?
- Когда prepared statements неэффективны?

**Как правильно обрабатывать транзакции с retry логикой?**
- Как обрабатывать deadlocks и serialization failures?
- Какие паттерны для retry транзакций?
- Как тестировать transactional логику?

### К вопросу 32 (ORM проблемы)

**Как избежать N+1 проблемы без преждевременной оптимизации?**
- Какие инструменты для обнаружения N+1 запросов?
- Как использовать eager loading в ORM?
- Когда ручные JOIN эффективнее ORM?

**Когда стоит использовать raw SQL вместо ORM?**
- В каких сценариях raw SQL предпочтительнее?
- Как мигрировать между ORM и raw SQL?
- Какие библиотеки для query builder?

**Как ORM влияет на миграции схемы базы данных?**
- Какие инструменты для миграций в Go?
- Как управлять версиями схемы?
- Как тестировать миграции?

## Практические нюансы

### К вопросу 9 (defer)

**Как defer влияет на производительность? Когда это значимо?**
- Какие overhead у defer в hot paths?
- Как компилятор оптимизирует defer?
- Когда стоит избегать defer в performance-critical коде?

**Что такое "defer panic" и как это обрабатывать?**
- Что происходит при panic в defer функции?
- Как recover работает внутри defer?
- Какие best practices для error handling в defer?

**Как изменить возвращаемое значение функции в defer?**
- Как использовать named return values с defer?
- Когда изменять возвращаемые значения в defer оправдано?
- Какие подводные камни у этого подхода?

### К вопросу 10 (panic/recover)

**Какие best practices использования panic/recover?**
- В каких сценариях panic/recover уместны?
- Как организовать panic recovery на верхнем уровне?
- Какие ошибки не стоит обрабатывать через recover?

**Как обрабатывать panics в goroutine?**
- Что происходит с panic в отдельной goroutine?
- Как предотвратить падение всего приложения?
- Какие паттерны для panic recovery в goroutine pool?

**Когда использовать panic для бизнес-логики?**
- Почему panic не рекомендуется для бизнес-ошибок?
- Какие исключительные ситуации оправдывают panic?
- Как мигрировать с panic на error возвраты?

## Архитектурные паттерны

### К вопросу 13 (архитектура приложения)

**Как организовать валидацию в разных слоях приложения?**
- Где валидировать input данные (transport vs service layer)?
- Какие библиотеки для валидации в Go?
- Как организовать validation errors между слоями?

**Как обрабатывать ошибки между слоями?**
- Какие паттерны для error wrapping и unwrapping?
- Как передавать context ошибок между слоями?
- Какие best practices для error handling в микросервисах?

**Как реализовать CQRS на Go?**
- Какие преимущества CQRS для Go приложений?
- Как организовать event sourcing с Go?
- Какие проекционные паттерны для read models?

### К вопросу 14 (worker pool)

**Как реализовать dynamic worker pool?**
- Как масштабировать количество workers динамически?
- Какие метрики для autoscaling worker pool?
- Как балансировать нагрузку между workers?

**Как обрабатывать graceful shutdown worker pool?**
- Как дождаться завершения текущих задач?
- Как обрабатывать незавершенные задачи при shutdown?
- Какие timeout для graceful shutdown worker pool?

**Как балансировать нагрузку между worker'ами?**
- Какие алгоритмы балансировки (round-robin, least connections)?
- Как учитывать capacity разных workers?
- Как обрабатывать slow workers?

## Производственные вопросы

### К вопросу 25 (production сборка)

**Как использовать build tags для feature flags?**
- Какие подходы к feature toggles в Go?
- Как управлять feature flags в runtime?
- Какие best practices для A/B testing?

**Как уменьшить размер бинарника?**
- Какие флаги компиляции для оптимизации размера?
- Как удалять debug информацию?
- Какие инструменты для анализа размера бинарника?

**Как настраивать разные конфигурации для разных окружений?**
- Какие подходы к configuration management?
- Как использовать environment variables эффективно?
- Какие библиотеки для configuration в Go?

## Общие уточняющие вопросы

**"Расскажите о самом сложном баге, который вы исправляли в Go"**
- Какие инструменты помогли в отладке?
- Как воспроизвести сложную race condition?
- Какие уроки извлекли из этого опыта?

**"Как вы мониторите производительность Go приложений в production?"**
- Какие метрики собираете (GC, goroutines, memory)?
- Как настраиваете alerts для performance degradation?
- Какие инструменты для APM в Go экосистеме?

**"Какие ограничения Go вы встречали в реальных проектах и как обходили?"**
- В каких сценариях Go не оптимален?
- Как интегрировать Go с другими языками?
- Какие архитектурные компромиссы делали из-за ограничений Go?

**"Как вы принимаете решение между sync и async обработкой?"**
- Какие критерии для выбора синхронной vs асинхронной архитектуры?
- Как измерять throughput и latency в каждом подходе?
- Какие сложности debugging async кода в Go?
