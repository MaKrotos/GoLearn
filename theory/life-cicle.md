# Жизненный цикл горутины в Go

## Введение

Горутина (goroutine) - это легковесный поток выполнения в языке программирования Go, управляемый средой выполнения Go (runtime). В отличие от традиционных потоков операционной системы, горутины значительно более эффективны с точки зрения использования ресурсов и переключения контекста.

## Этапы жизненного цикла горутины

### 1. Создание (Creation)

Горутина создается с помощью ключевого слова `go`, за которым следует вызов функции. При создании горутина не выполняется немедленно, а помещается в очередь планировщика для последующего выполнения.

```go
// Создание горутины
go func() {
    fmt.Println("Горутина выполняется")
}()
```

Важные аспекты создания горутин:
- Начальный размер стека горутины составляет 2 КБ
- Стек может динамически расти и сжиматься по мере необходимости
- Создание горутины требует минимальных накладных расходов

### 2. Выполнение (Execution)

Планировщик Go (Goroutine Scheduler) отвечает за распределение горутин между потоками операционной системы. Go использует M:N планировщик, который мультиплексирует M горутин на N потоков ОС.

```go
func main() {
    // Создание нескольких горутин
    for i := 1; i <= 3; i++ {
        go func(workerID int) {
            fmt.Printf("Горутина %d выполняет задание\n", workerID)
        }(i)
    }
    
    time.Sleep(time.Second) // Ожидание завершения выполнения
}
```

Планировщик Go:
- Следит за состоянием всех горутин
- Распределяет нагрузку между доступными потоками ОС
- Использует алгоритм "work-stealing" для балансировки нагрузки

### 3. Блокировка (Blocking)

Горутина может перейти в состояние блокировки при ожидании различных событий:

#### Ожидание операций ввода-вывода:
```go
func ioOperation() {
    // Горутина блокируется во время сетевых операций
    resp, err := http.Get("https://api.example.com")
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    
    // Обработка ответа
}
```

#### Ожидание операций с каналами:
```go
func channelOperation() {
    ch := make(chan string)
    
    go func() {
        // Отправка данных в канал
        ch <- "Данные"
    }()
    
    // Блокировка до получения данных из канала
    data := <-ch
    fmt.Println("Получено:", data)
}
```

#### Ожидание освобождения мьютексов:
```go
import "sync"

func mutexOperation() {
    var mu sync.Mutex
    mu.Lock()
    
    go func() {
        // Блокировка до освобождения мьютекса
        mu.Lock()
        fmt.Println("Мьютекс захвачен")
        mu.Unlock()
    }()
    
    time.Sleep(time.Second)
    mu.Unlock() // Освобождение мьютекса
}
```

Поведение планировщика при блокировке:
- Блокированная горутина не потребляет ресурсы процессора
- Планировщик назначает другие горутины для выполнения
- При разблокировке горутина возвращается в очередь выполнения

### 4. Продолжение (Resumption)

Когда условие блокировки устраняется, горутина автоматически возвращается в состояние выполнения:

```go
func resumptionExample() {
    done := make(chan bool)
    
    go func() {
        fmt.Println("Горутина начинает выполнение")
        time.Sleep(2 * time.Second) // Имитация работы
        done <- true // Сигнал о завершении
    }()
    
    // Ожидание завершения горутины
    <-done
    fmt.Println("Горутина завершена")
}
```

Процесс возобновления:
1. Устранение условия блокировки
2. Планировщик помещает горутину в очередь выполнения
3. Горутина продолжает выполнение с точки останова

### 5. Завершение (Termination)

Горутина завершается в следующих случаях:
- Достигнут конец функции
- Вызов `return`
- Возникновение паники (panic) без восстановления

```go
func terminationExample() {
    go func() {
        fmt.Println("Начало выполнения")
        // Выполнение некоторой работы
        fmt.Println("Завершение выполнения")
        // Автоматическое завершение при достижении конца функции
    }()
    
    time.Sleep(time.Second)
    fmt.Println("Все горутины завершены")
}
```

## Правильные практики работы с горутинами

### Передача параметров в горутины

Правильный способ:
```go
// Передача параметров через замыкание
for i := 0; i < 3; i++ {
    go func(workerNumber int) {
        fmt.Printf("Горутина %d\n", workerNumber)
    }(i) // Передаем копию значения
}
```

Неправильный способ:
```go
// Все горутины используют одну переменную
for i := 0; i < 3; i++ {
    go func() {
        fmt.Printf("Горутина %d\n", i) // Ошибка! Все увидят одно значение
    }()
}
```

### Ожидание завершения горутин

Использование sync.WaitGroup:
```go
func waitForGoroutines() {
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Горутина %d выполняется\n", id)
            time.Sleep(time.Second)
            fmt.Printf("Горутина %d завершена\n", id)
        }(i)
    }
    
    wg.Wait() // Ожидание завершения всех горутин
    fmt.Println("Все горутины завершены")
}
```

## Заключение

Понимание жизненного цикла горутин является ключевым аспектом эффективного программирования на Go. Правильное использование горутин позволяет создавать высокопроизводительные и масштабируемые приложения, эффективно использующие ресурсы системы.
