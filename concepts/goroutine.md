# Горутина (Goroutine) - объяснение для чайников

## Что такое горутина?

Представьте, что вы повар в ресторане. Обычные программы работают как повар, который делает одно блюдо за другим - сначала суп, потом котлеты, потом десерт. Это называется **последовательное выполнение**.

Горутина - это как если бы у вас было много помощников-поваров, каждый из которых может готовить свое блюдо одновременно. Один готовит суп, другой жарит котлеты, третий делает десерт. Это называется **параллельное выполнение**.

## Техническое определение

Горутина - это **легковесный поток выполнения**, управляемый **рантаймом Go**[^runtime]. 

Ключевые особенности:
- Очень "дешевые" для создания (начинаются с ~2KB стека)
- Управляются планировщиком Go, а не операционной системой
- Могут быть тысячи горутин в одном приложении
- Быстрое переключение между горутинами

## Почему горутины "легковесные"?

### Сравнение с потоками ОС

| Характеристика | Поток ОС | Горутина |
|----------------|----------|----------|
| Накладные расходы на создание | Высокие (~1MB стека) | Низкие (~2KB стека) |
| Управление | Операционная система | Рантайм Go |
| Количество в системе | Ограничено (сотни) | Тысячи |
| Переключение контекста | Медленное | Быстрое |

## Как создать горутину?

```go
// Обычная функция
func sayHello() {
    fmt.Println("Привет!")
}

func main() {
    // Создаем горутину с помощью ключевого слова go
    go sayHello()
    
    // ВАЖНО: без этой задержки программа может завершиться
    // до выполнения горутины
    time.Sleep(1 * time.Second)
}
```

## Пример из жизни

Представьте, что вы хотите отправить email 1000 пользователям:

**Без горутин (последовательно):**
```go
func sendEmailsSequential() {
    for i := 0; i < 1000; i++ {
        sendEmail(i) // Каждый email отправляется по очереди
    }
    // Если отправка одного email занимает 1 секунду,
    // то всего потребуется 1000 секунд (~17 минут)
}
```

**С горутинами (параллельно):**
```go
func sendEmailsWithGoroutines() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(userID int) {
            defer wg.Done()
            sendEmail(userID) // Все email отправляются одновременно
        }(i)
    }
    
    wg.Wait()
    // Все 1000 email отправляются почти одновременно,
    // занимая примерно 1 секунду
}
```

## Когда использовать горутины?

1. **Параллельная обработка данных** - обработка множества файлов, записей в БД
2. **Асинхронные операции** - отправка email, обработка изображений
3. **Серверные приложения** - обработка множества запросов одновременно
4. **Фоновые задачи** - логирование, мониторинг

## Важные моменты

1. **Горутина не гарантирует немедленного выполнения** - она ставится в очередь планировщика
2. **Основная функция main() может завершиться раньше** - используйте sync.WaitGroup или time.Sleep для ожидания
3. **Гонки данных** - если несколько горутин обращаются к одной переменной, используйте мьютексы или каналы

## См. также

- [Каналы](channel.md) - для коммуникации между горутинами
- [Мьютексы](mutex.md) - для защиты общих данных
- [Планировщик Go](scheduler.md) - как Go управляет горутинами

[^runtime]: **Рантайм** - это среда выполнения, которая управляет запуском программы. В случае Go, это встроенный в язык механизм, который управляет горутинами, сборкой мусора и другими аспектами выполнения программы.