# Мьютекс (Mutex) - объяснение для чайников

## Что такое мьютекс?

Представьте, что у вас есть **общая комната с одним стулом**. Несколько людей хотят сесть на этот стул, но только один может сидеть одновременно. 

Мьютекс - это как **ключ от комнаты**. Человек, который хочет сесть, должен сначала получить ключ. Пока он сидит, другие не могут войти. Когда он встает, он возвращает ключ, и его может взять следующий человек.

В программировании мьютекс защищает **общие ресурсы** от одновременного доступа.

## Техническое определение

Мьютекс (от "mutual exclusion" - "взаимное исключение") - это **примитив синхронизации**, который **позволяет только одной горутине одновременно получать доступ к защищенному ресурсу**.

## Когда нужен мьютекс?

### Пример проблемы без мьютекса

```go
var counter int // Общий ресурс

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // ОШИБКА: несколько горутин одновременно изменяют counter
        }()
    }
    
    wg.Wait()
    fmt.Println("Счетчик:", counter) // Результат будет разным каждый раз!
}
```

Проблема называется **"гонка данных" (data race)** - несколько горутин одновременно изменяют одну переменную.

### Решение с мьютексом

```go
var (
    counter int
    mutex   sync.Mutex // Мьютекс для защиты counter
)

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mutex.Lock()   // Получаем "ключ"
            counter++      // Безопасно изменяем counter
            mutex.Unlock() // Возвращаем "ключ"
        }()
    }
    
    wg.Wait()
    fmt.Println("Счетчик:", counter) // Всегда будет 1000
}
```

## Типы мьютексов в Go

### 1. sync.Mutex (простой мьютекс)

```go
var mutex sync.Mutex

// Захват мьютекса
mutex.Lock()

// Освобождение мьютекса
mutex.Unlock()
```

### 2. sync.RWMutex (читатель-писатель мьютекс)

Позволяет множественным читателям или одному писателю:

```go
var rwMutex sync.RWMutex

// Для чтения (множество горутин могут читать одновременно)
rwMutex.RLock()
// чтение данных
rwMutex.RUnlock()

// Для записи (только одна горутина может писать)
rwMutex.Lock()
// запись данных
rwMutex.Unlock()
```

## Практические примеры

### Пример 1: Защита счетчика

```go
type Counter struct {
    value int
    mutex sync.Mutex
}

func (c *Counter) Increment() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    return c.value
}
```

### Пример 2: Защита карты (map)

```go
type SafeMap struct {
    data map[string]int
    mutex sync.RWMutex
}

func (sm *SafeMap) Set(key string, value int) {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    value, exists := sm.data[key]
    return value, exists
}
```

## Важные правила использования

### 1. Всегда освобождайте мьютекс

```go
// ПРАВИЛЬНО
mutex.Lock()
// работа с защищенными данными
mutex.Unlock()

// ЕЩЕ ЛУЧШЕ
mutex.Lock()
defer mutex.Unlock() // Автоматическое освобождение
// работа с защищенными данными
```

### 2. Не копируйте мьютексы

```go
// НЕПРАВИЛЬНО
func badFunction(mutex sync.Mutex) {
    // Копирование мьютекса приведет к проблемам
}

// ПРАВИЛЬНО
func goodFunction(mutex *sync.Mutex) {
    // Передаем указатель на мьютекс
}
```

### 3. Избегайте длительных блокировок

```go
// ПЛОХО
mutex.Lock()
defer mutex.Unlock()

time.Sleep(10 * time.Second) // Долгая операция под блокировкой
// Другие горутины ждут!

// ЛУЧШЕ
mutex.Lock()
data := protectedData
mutex.Unlock()

// Долгая операция без блокировки
time.Sleep(10 * time.Second)

mutex.Lock()
protectedData = newData
mutex.Unlock()
```

## Mutex vs Channels

### Когда использовать мьютексы:
1. **Защита состояния** - когда нужно защитить переменные или структуры данных
2. **Простая синхронизация** - когда не нужна коммуникация между горутинами
3. **Высокая производительность** - для простых случаев мьютексы быстрее каналов

### Когда использовать каналы:
1. **Коммуникация** - когда нужно передавать данные между горутинами
2. **Координация** - когда нужно координировать выполнение горутин
3. **Паттерны** - worker pools, fan-in/fan-out и т.д.

## Распространенные ошибки

### 1. Забытый Unlock
```go
// ОШИБКА
mutex.Lock()
if someCondition {
    return // Забыли Unlock! Другие горутины заблокированы навсегда
}
mutex.Unlock()
```

### 2. Паника под блокировкой
```go
// ОШИБКА
mutex.Lock()
defer mutex.Unlock()

panic("Что-то пошло не так") // Мьютекс не будет освобожден
```

### 3. Взаимная блокировка (deadlock)
```go
// ОШИБКА
mutex1.Lock()
mutex2.Lock() // Если другая горутина держит mutex2 и ждет mutex1

// В другой горутине:
mutex2.Lock()
mutex1.Lock() // DEADLOCK!
```

## Лучшие практики

1. **Используйте defer** для автоматического освобождения
2. **Держите блокировку минимальное время**
3. **Избегайте вложенных блокировок**
4. **Тестируйте с -race** для обнаружения гонок данных
5. **Рассмотрите альтернативы** - каналы, atomic операции

## См. также

- [Горутины](goroutine.md) - что такое горутины
- [Каналы](channel.md) - альтернативный способ синхронизации
- [Atomic операции](atomic.md) - еще один способ защиты данных
- [Context](context.md) - для отмены операций