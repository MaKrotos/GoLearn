# WaitGroup в Go

## Что такое WaitGroup

`WaitGroup` - это тип в пакете `sync`, который позволяет дождаться завершения нескольких горутин. Он используется для синхронизации выполнения горутин, когда основная горутина должна дождаться завершения всех запущенных горутин.

WaitGroup особенно полезен в ситуациях, когда необходимо:
- Запустить несколько параллельных задач и дождаться их завершения
- Координировать завершение работы приложения
- Синхронизировать тесты, которые запускают горутины
## Как устроен WaitGroup внутри

WaitGroup использует атомарные операции для отслеживания состояния. Внутри он содержит:


### Внутренняя структура

Внутри WaitGroup реализован как структура с приватными полями:

```go
type WaitGroup struct {
    noCopy noCopy // предотвращает копирование
    state1 [3]uint32 // содержит счетчик, waiter count и semaphore
}
```

### Атомарные операции

WaitGroup использует атомарные операции для обеспечения потокобезопасности:
- `Add()` использует атомарное сложение для изменения счетчика
- `Done()` уменьшает счетчик атомарно
- `Wait()` использует атомарные операции для проверки состояния

### Механизм блокировки

Когда счетчик больше 0, вызов `Wait()` блокирует горутину:
1. Горутина добавляется в список ожидающих
2. Используется семафор для блокировки
3. При достижении счетчиком 0, все заблокированные горутины разблокируются
1. **Счетчик** - отслеживает количество активных горутин
2. **Семафор** - для блокировки потоков при ожидании
3. **Состояние** - для управления жизненным циклом

Основные методы:
- `Add(delta int)` - добавляет delta к счетчику
- `Done()` - уменьшает счетчик на 1 (эквивалентно Add(-1))
- `Wait()` - блокирует вызывающую горутину до тех пор, пока счетчик не станет равным 0

## Пример использования

### Расширенный пример использования

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func fetchData(source string, wg *sync.WaitGroup, results chan<- string) {
    defer wg.Done()
    
    // Симуляция работы с разными временами выполнения
    sleepTime := time.Duration(len(source)) * time.Millisecond * 100
    time.Sleep(sleepTime)
    
    result := fmt.Sprintf("Данные из %s получены за %v", source, sleepTime)
    results <- result
}

func main() {
    var wg sync.WaitGroup
    results := make(chan string, 3)
    
    // Запуск нескольких горутин для получения данных
    sources := []string{"API1", "API2", "API3"}
    
    for _, source := range sources {
        wg.Add(1)
        go fetchData(source, &wg, results)
    }
    

## Лучшие практики

1. **Всегда используйте указатель**: Передавайте WaitGroup по указателю, так как он изменяет внутреннее состояние
2. **Вызов Done() через defer**: Используйте `defer wg.Done()` в начале горутины для гарантии вызова
3. **Проверка счетчика**: Убедитесь, что счетчик не становится отрицательным
4. **Избегайте копирования**: WaitGroup содержит `noCopy` для предотвращения копирования

## Распространенные ошибки

1. **Забытый Add()**: Не вызван `Add()` перед запуском горутины
2. **Забытый Done()**: Не вызван `Done()` в горутине
3. **Неправильное количество Add()**: Несоответствие между `Add()` и `Done()`
4. **Повторный Wait()**: Повторный вызов `Wait()` после использования

## Сравнение с другими примитивами синхронизации

### WaitGroup vs Channel
- WaitGroup: Проще для ожидания завершения фиксированного числа горутин
- Channel: Более гибкий для передачи данных между горутинами

### WaitGroup vs Mutex
- WaitGroup: Для координации завершения горутин
- Mutex: Для защиты общих ресурсов от одновременного доступа
    // Закрытие канала после завершения всех горутин
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Чтение результатов
    for result := range results {
        fmt.Println(result)
    }
    
    fmt.Println("Все данные получены")
}
```

### Паттерны использования WaitGroup

1. **Fan-out/Fan-in**: Запуск множества горутин для параллельной обработки и ожидание их завершения
2. **Координирование тестов**: Ожидание завершения всех горутин в тестах
3. **Гraceful shutdown**: Координация завершения работы приложения

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Уменьшаем счетчик при завершении
    fmt.Printf("Горутина %d начала работу\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Горутина %d завершила работу\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 3; i++ {
        wg.Add(1) // Увеличиваем счетчик
        go worker(i, &wg)
    }
    
    wg.Wait() // Ждем завершения всех горутин
    fmt.Println("Все горутины завершены")
}
```

## Типизация WaitGroup

WaitGroup имеет строгую типизацию и реализует следующие методы:

```go
type WaitGroup struct {
    // содержит скрытые поля
}

func (wg *WaitGroup) Add(delta int)
func (wg *WaitGroup) Done()
func (wg *WaitGroup) Wait()
```

Важно передавать WaitGroup по указателю, так как он изменяет внутреннее состояние.

## Практическое применение

WaitGroup часто используется в:
- Параллельной обработке данных
- Запуске фоновых задач
- Синхронизации тестов
- Реализации паттернов конкурентности