# Слайсы и мапы в Go

## Слайсы (Slices)

### Что такое слайс

Слайс в Go - это динамический массив, который представляет собой сегмент базового массива. Слайс состоит из трех компонентов:
1. Указатель на базовый массив
2. Длина (len) - количество элементов в слайсе
3. Вместимость (cap) - количество элементов в базовом массиве начиная с позиции указателя

### Внутреннее устройство слайсов

Слайс реализован как структура:
```go
type slice struct {
    array unsafe.Pointer // указатель на базовый массив
    len   int            // длина
    cap   int            // вместимость
}
```

### Детали внутреннего устройства слайсов

Слайс в Go - это дескриптор для базового массива. Важно понимать, что слайс не хранит данные напрямую, а лишь ссылается на часть массива.

#### Структура слайса в памяти

```go
type slice struct {
    array unsafe.Pointer // указатель на базовый массив
    len   int            // длина слайса
    cap   int            // вместимость слайса
}
```

#### Как работает слайсинг

При создании подслайса через `slice[i:j]`:
- Указатель перемещается на i-й элемент базового массива
- Длина становится `j-i`
- Вместимость становится `cap(slice)-i`

Пример:
```go
original := make([]int, 5, 10) // len=5, cap=10
sub := original[2:4]           // len=2, cap=8
```

#### Внутреннее представление

Слайсы в Go реализованы как структуры с тремя полями:
1. **Указатель**: ссылка на первый элемент слайса в базовом массиве
2. **Длина**: количество элементов в слайсе
3. **Вместимость**: максимальное количество элементов от начала слайса до конца базового массива

Это позволяет эффективно работать с подмножествами данных без копирования.

### Создание слайсов

```go
// Создание слайса с помощью make
slice1 := make([]int, 5)      // len=5, cap=5
slice2 := make([]int, 3, 10)  // len=3, cap=10

// Создание слайса из массива
arr := [5]int{1, 2, 3, 4, 5}
slice3 := arr[1:4]  // элементы с индекса 1 по 3

// Создание слайса литералом
slice4 := []int{1, 2, 3, 4, 5}
```

### Глубокое понимание append

Функция `append` в Go имеет сложное поведение, зависящее от вместимости:

#### Стратегия роста слайсов

Алгоритм роста слайсов в Go:
1. Если `len + needed <= cap` - используется существующий массив
2. Если нужен новый массив:
   - При малых размерах (len < 1024) - удваивается
   - При больших размерах - растет примерно на 25%

#### Примеры поведения append


### Детали внутреннего устройства мап

Мапы в Go реализованы как хеш-таблицы с использованием алгоритма хеширования.

#### Структура мапы

Внутренне мапа состоит из:
1. **Бакетов (buckets)**: массив структур для хранения данных
2. **Хеш-функции**: для распределения ключей по бакетам
3. **Механизма роста**: при переполнении

#### Бакеты

Каждый бакет содержит:
- Массив из 8 ячеек для хранения пар ключ-значение
- Битовый массив для отслеживания используемых ячеек
- Указатель на следующий переполненный бакет (overflow bucket)

#### Хеширование

Go использует алгоритм хеширования murmurhash:
1. Ключ хешируется в 64-битное значение
2. Младшие биты определяют номер бакета
3. Старшие биты используются для различения ключей в одном бакете

#### Рост мапы

Мапа растет при достижении load factor (заполненность) определенного порога:
- При load factor > 6.5 мапа удваивается в размере
- Все существующие пары перераспределяются по новым бакетам

### Конкурентный доступ к мапам

#### Проблемы конкурентного доступа

```go
// Опасный код - может вызвать panic
var m = make(map[string]int)

func worker() {
    for i := 0; i < 1000; i++ {
        m["key"] = i  // запись
        _ = m["key"]  // чтение
    }
}

// Запуск нескольких горутин
go worker()
go worker()  // panic: concurrent map read and map write
```

#### Решения для конкурентного доступа

1. **sync.Mutex**:
```go
var (
    m  = make(map[string]int)
    mu sync.RWMutex
)

func safeWrite(key string, value int) {
    mu.Lock()
    m[key] = value
    mu.Unlock()
}

func safeRead(key string) (int, bool) {
    mu.RLock()
    value, exists := m[key]
    mu.RUnlock()
    return value, exists
}
```

2. **sync.Map** (для специфических случаев):
```go
var m sync.Map

func concurrentWrite(key string, value int) {
    m.Store(key, value)
}

### Производительность слайсов и мап

#### Слайсы

Операции со слайсами по сложности:
- Доступ по индексу: O(1)
- append (без реаллокации): O(1)
- append (с реаллокацией): O(n)
- copy: O(n)
- slice[i:j]: O(1)

#### Мапы

Операции с мапами по сложности:
- Вставка: O(1) в среднем, O(n) в худшем случае
- Поиск: O(1) в среднем, O(n) в худшем случае
- Удаление: O(1) в среднем, O(n) в худшем случае

### Лучшие практики

#### Для слайсов

1. **Предварительная аллокация**:
```go
// Плохо
var slice []int
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}

// Хорошо
slice := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}
```

2. **Избегайте утечек памяти**:
```go
// Плохо
big := make([]int, 1000000)
small := big[:10]

// Хорошо
small := make([]int, 10)
copy(small, big[:10])
```

#### Для мап

1. **Предварительная аллокация**:
```go
// Если известно количество элементов
m := make(map[string]int, 1000)
```

2. **Избегайте частого роста**:
```go
// Плохо - частые реаллокации
m := make(map[string]int)
for i := 0; i < 10000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}

// Хорошо - одна аллокация
m := make(map[string]int, 10000)
for i := 0; i < 10000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}
```

### Распространенные ошибки

#### Слайсы

1. **Изменение подслайсов влияет на оригинальный массив**:
```go
original := []int{1, 2, 3, 4, 5}
sub := original[1:3]
sub[0] = 999  // изменяет original[1]
```

2. **Неправильное использование cap**:
```go
slice := make([]int, 5, 10)
// cap(slice) = 10, но len(slice) = 5
// slice[5] и выше недоступны без append
```

#### Мапы

1. **Чтение из nil мапы безопасно, запись - нет**:
```go
var m map[string]int
_ = m["key"]  // безопасно, вернет zero value
m["key"] = 1  // panic: assignment to entry in nil map
```

2. **Итерация с удалением**:
```go
// Неопределенное поведение
for key := range m {
    delete(m, key)  // не рекомендуется
}
```

func concurrentRead(key string) (int, bool) {
    value, ok := m.Load(key)
    if !ok {
        return 0, false
    }
    return value.(int), true
}
```
```go
// Пример 1: Без реаллокации
slice := make([]int, 5, 10)
originalPtr := &slice[0]
slice = append(slice, 1)
newPtr := &slice[0]
// originalPtr == newPtr (тот же массив)

// Пример 2: С реаллокацией
slice = make([]int, 5, 5)
originalPtr = &slice[0]
slice = append(slice, 1)
newPtr = &slice[0]
// originalPtr != newPtr (новый массив)
```

#### Важные особенности

1. **append возвращает новый слайс**: Исходный слайс может быть изменен
2. **Копирование при реаллокации**: Все элементы копируются в новый массив
3. **Передача по значению**: Слайс как структура копируется, но указатель на массив общий

### Работа с памятью слайсов

#### Утечки памяти

Слайсы могут вызывать утечки памяти:

```go
// Проблема: большой базовый массив остается в памяти
big := make([]int, 1000000)
small := big[:10]  // len=10, но cap=1000000

// Решение: создать копию
small = append([]int(nil), big[:10]...)
```

#### Оптимизация памяти

1. Используйте `make([]T, len, cap)` с правильной вместимостью
2. Освобождайте ссылки на большие слайсы
3. Используйте `copy()` для явного копирования данных

### Типизация слайсов

Слайсы имеют тип `[]T`, где T - тип элементов. Например:
- `[]int` - слайс целых чисел
- `[]string` - слайс строк
- `[][]int` - слайс слайсов целых чисел

Слайсы типизированы строго, слайс `[]int` и `[]string` - это разные типы.

### Основные операции со слайсами

```go
slice := []int{1, 2, 3, 4, 5}

// Получение длины и вместимости
length := len(slice)     // 5
capacity := cap(slice)   // 5

// Добавление элементов
slice = append(slice, 6)        // добавить один элемент
slice = append(slice, 7, 8, 9)  // добавить несколько элементов

// Копирование слайсов
newSlice := make([]int, len(slice))
copy(newSlice, slice)

// Слайсинг (создание подслайса)
subSlice := slice[1:4]  // элементы с индекса 1 по 3
```

### Как работает append

При вызове `append` проверяется, достаточно ли вместимости:
- Если достаточно, элементы добавляются в существующий массив
- Если недостаточно, создается новый массив большего размера (обычно в 2 раза), данные копируются, и добавляются новые элементы

## Мапы (Maps)

### Что такое мапа

Мапа в Go - это хеш-таблица, которая хранит пары ключ-значение. Мапы неупорядочены.

### Внутреннее устройство мап

Мапа реализована как хеш-таблица с использованием алгоритма хеширования. Внутри мапа состоит из:
1. Бакетов (buckets) - массив структур для хранения данных
2. Хеш-функции для распределения ключей по бакетам
3. Механизма роста при переполнении

Каждый бакет может содержать до 8 пар ключ-значение. При переполнении создаются дополнительные бакеты.

### Создание мап

```go
// Создание пустой мапы
map1 := make(map[string]int)

// Создание мапы с инициализацией
map2 := map[string]int{
    "one": 1,
    "two": 2,
    "three": 3,
}

// Нулевое значение мапы равно nil
var map3 map[string]int  // nil мапа
```

### Типизация мап

Мапы имеют тип `map[K]V`, где K - тип ключа, V - тип значения:
- `map[string]int` - мапа со строковыми ключами и целочисленными значениями
- `map[int]bool` - мапа с целочисленными ключами и булевыми значениями

Ключи должны быть сравниваемыми типами (не могут быть слайсами, мапами, функциями).

### Основные операции с мапами

```go
// Создание мапы
ages := make(map[string]int)

// Добавление/обновление элементов
ages["Alice"] = 25
ages["Bob"] = 30

// Получение значения
age, exists := ages["Alice"]  // age=25, exists=true
age, exists = ages["Charlie"] // age=0, exists=false

// Удаление элемента
delete(ages, "Bob")

// Проверка длины
length := len(ages)

// Итерация по мапе
for key, value := range ages {
    fmt.Printf("%s: %d\n", key, value)
}
```

### Особенности мап

1. **Потокобезопасность**: Мапы не являются потокобезопасными. При конкурентном доступе необходима синхронизация.
2. **Нулевое значение**: Нулевое значение мапы равно `nil`. Попытка записи в nil мапу вызовет панику.
3. **Сравнение**: Мапы нельзя сравнивать между собой (кроме сравнения с nil).

## Примеры использования

### Работа со слайсами

```go
package main

import "fmt"

func main() {
    // Создаем слайс
    numbers := []int{1, 2, 3, 4, 5}
    
    // Добавляем элементы
    numbers = append(numbers, 6, 7, 8)
    
    // Создаем подслайс
    subset := numbers[2:5]  // [3, 4, 5]
    
    // Итерация
    for i, num := range numbers {
        fmt.Printf("Индекс: %d, Значение: %d\n", i, num)
    }
}
```

### Работа с мапами

```go
package main

import "fmt"

func main() {
    // Создаем мапу
    scores := map[string]int{
        "Alice": 95,
        "Bob":   87,
        "Charlie": 92,
    }
    
    // Добавляем элемент
    scores["David"] = 88
    
    // Получаем значение
    if score, exists := scores["Alice"]; exists {
        fmt.Printf("Оценка Alice: %d\n", score)
    }
    
    // Итерация по мапе
    for name, score := range scores {
        fmt.Printf("%s: %d\n", name, score)
    }
}
```

## Практические рекомендации

1. **Слайсы**: Используйте `make` с указанием вместимости, если известен предполагаемый размер
2. **Мапы**: Используйте `make` с указанием размера, если известно количество элементов
3. **Проверка существования**: Всегда проверяйте второе возвращаемое значение при получении из мапы
4. **Конкурентный доступ**: Используйте мьютексы или другие механизмы синхронизации при конкурентном доступе к мапам